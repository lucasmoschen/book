\chapter{Conjuntos}
\section{Introdução}
Para tratar de conjuntos iremos tentar uma abordagem que não deixe de lado o rigor matemático necessário, mas que ao mesmo tempo permita utilizar o Lean e contextualizar exemplos do dia a dia.

Caro leitor, como você definiria conjunto? Vamos, pense um pouco. No século XIX, o matemático Georg Cantor, no jornal acadêmico Mathematische Annalen, descreveu um conjunto (ou utilizando sua terminologia, \textit{Menge}) como, em tradução livre: ``Por conjunto nós entendemos qualquer coleção $M$ de objetos deteminados e distintos (chamados de elementos de $M$) da nossa intuição ou do nosso pensamento em um todo."

Ou seja, mesmo um conjunto podendo ser algo tão abstrato quanto os números naturais ($\mathbb{N}$), os números reais ($\mathbb{R}$) e o Conjunto de Cantor, podemos ter coisas menos abstratas como o conjunto das palavras desse texto, o dos planetas do Sistema Solar ou até dos alunos de sua turma. A questão é, todos esses conjuntos podem ser mais intuitivos ou abstratos (além de como são definidos) dependendo da pessoa que irá interpretá-los, por exemplo, o conjunto dos naturais pode ser definido como $\mathbb{N} = \{1,2,3,...\}$ ou $\mathbb{N}=\{0,1,2,3,...\}$ (para não desagradar ninguém), o de planetas do Sistema Solar $ P = \{ Mercurio, Venus, Ter$-$\\ra, Marte, Jupiter, Saturno, Urano, Netuno \}$ (lembramos que se este livro fosse escrito há uns 15 anos, Plutão ainda seria considerado como um planeta, isto é, estaria no conjunto), por consequência, vemos que a interpretação do que determinado conjunto representa varia de pessoa para pessoa, mesmo que a ideia principal continue a mesma.

Nosso intuito, durante essa aventura pelo mundo dos conjuntos será entender melhor certos conceitos e definições (como o fato do conjunto vazio estar contido em todos os conjuntos), através de demonstrações, exemplos e exercícios, aumentando sua capacidade de abstração e a nossa também, já que para escrever esse capítulo nós teremos que ir além, pois não queremos apenas entender o que está aqui, mas que você entenda e aprenda também.

\section{Fundamentações}
\subsection{Notações}
Nesta seção iremos começar a introduzir notações matemáticas e algumas definições sobre conjuntos.

$\qquad$

\textbf{Pertence e Não Pertence:} Quando um determinado elemento $x$ faz parte de determinado conjunto $A$, nós dizemos que $x$ pertence a $A$ (denotamos $x \in A$). Caso $x$ não faça parte de $A$, diz-se que $x$ não pertence a $A$ (denota-se  $x \notin A$).

$\qquad$

\textbf{Contém, Contido e similares:} Já quando um conjunto $B$ possui todos os elementos que $A$ possui e, $B$ tem, pelo menos, um objeto que $A$ não possua, dizemos que $A$ está contido em $B$ ($\space A \subset B$) ou que $B$ contém $A$ ($B \supset A$).  Também podemos chamar $A$ de subconjunto próprio de $B$.

Se não sabemos se $B$ possui um objeto que $A$ não possua (e $B$ ainda possui todos os elementos que $A$), denotamos $A \subseteq B$, que significa $A \subset B$ ou $A=B$, de modo equivalente $B \supseteq A$, significa $B \supset A$ ou $A=B$. Neste caso, dizemos que $A$ é um subconjunto de $B$.

Se $A$ possui pelo menos um elemento que $B$ não possua, dizemos que $A$ não está contido em $B$ ($A \not\subset B$) ou que $B$ não contém $B\not\supset A$, assim $A \neq B$.

$\qquad$

\textbf{Interseção:} Se estamos interessados em conjuntos/elementos que pertencem simultaneamente a dois conjuntos $A$ e $B$, dizemos que estamos interessados na interseção de $A$ e $B$ (denotada como $A \cap B$).

$\qquad$

\textbf{União:} Já se estamos interessados nos conjuntos/elementos que fazem parte de $A$ ou de $B$ dizemos que, nosso objetivo é a união de $A$ e $B$ ($A \cup B$).

$\qquad$

\textbf{Universo:} Quando estamos trabalhando com conjuntos é comum definirmos quem é nosso universo ($ \mathcal U $), isto é, o conjunto que conterá todos os conjuntos/elementos que estaremos trabalhando em um contexto. Por exemplo, na reta real nosso universo é $\mathcal U = \mathbb{R}$.

$\qquad$

\textbf{Conjunto Complementar:} Sendo $A$ um conjunto, dizemos que o conjunto $A$ complementar ou complemento de $A$ (denotado como $\overline A$ ou $A^C$) contém todos os conjuntos/elementos que não estão contidos/pertencem a $A$, mas fazem parte de nosso universo ($\mathcal U$).

$\qquad$

\textbf{Diferença de Conjuntos:} Quando temos dois conjuntos e nosso objetivo são os conjuntos/elementos que pertencem a um destes conjuntos, mas não do outro, dizemos que estamos interessados na diferença destes conjuntos. No caso, se queremos os conjuntos/elementos de $B$, mas não desejamos pegar os que também pertencem a $A$, queremos os elementos/conjuntos que pertencem a diferença de $B$ com $A$ (denotamos como $B-A$ ou $B \backslash A$).

$\qquad$

\textbf{Conjuntos Disjuntos:} Dois conjuntos são ditos disjuntos quando todos os elemento (diferente do elemento vazio) do conjunto $A$ não pertencem ao conjuntunto $B$. Ou seja, a interseção de $A$ e $B$ é vazia, isto é, o único elemento que a $A$ e $B$ "possuem" em comum é o elemento vazio.

$\qquad$

\textbf{Diferença Simétrica:} é igual a união das diferenças entre dois conjuntos, que também é equivalente a diferença entre a união (desses conjuntos) e a interseção (dos dois conjuntos). Ela é representada por $\bigtriangleup$. A diferença simétrica entre dois conjuntos $A$ e $B$ é expressa como $A \bigtriangleup B$. Ou seja, estamos dizendo que, $A \bigtriangleup B = (A \backslash B) \cup (B\backslash A) = (A \cup B) \backslash (A \cap B)$.

\subsection{Definições}

Seja $A$ e $B$ conjuntos quaisquers, $\mathcal{U}$ nosso universo e $\emptyset$ o conjunto vazio. Assim, temos formalmente (e em Linguagem de Primeira Ordem):

\begin{itemize}
\item \textbf{Conjunto Vazio}: $\emptyset = \{x | false\}$

\[\forall x (x \in \emptyset \iff \bot)\]

\qquad

\item \textbf{Universo}: $\mathcal{U} = \{x | true \}$

\[\forall x (x \in \mathcal{U} \iff \top)\]

\qquad

\item \textbf{União}: $A \cup B = \{x | x \in A \vee x \in B\}$

\[\forall x (x \in A \cup B \iff x \in A \vee x \in B)\]

\qquad

\item \textbf{Interseção}: $A \cap B = \{x | x \in A \wedge x \in B\}$

\[\forall x (x \in A \cap B \iff x \in A \wedge x \in B)\]

\qquad

\item \textbf{Diferença}: $A \backslash B = \{x | x \in A \wedge x \notin B\}$

\[\forall x (x \in A \backslash B \iff x \in A \wedge x \notin B)\]

\qquad

\item \textbf{Complementar}: $\overline A = \mathcal{U} \backslash A = \{x | x \in \mathcal{U} \land x \notin A\}$

\[\forall x (x \in \overline A \iff x \notin A)\]
\end{itemize} 

\subsection{Axiomas}
Agora iremos apresentar alguns axiomas que servirão como base para todo o desenvolvimento dos conteúdos aqui propostos. Quando utilizarmos a palavra elemento, estaremos utilizando-a com a ideia de que um conjunto que pertença a outro é um elemento do segundo, para evitar repetir o uso excessivo da palavra conjunto.

\textbf{Axioma da Extensão:} Dois conjuntos são iguais, se e somente se, todo elemento que pertence ao primeiro conjunto pertence ao segundo e todo elemento que pertence ao segundo também pertence ao primeiro, ou seja:

\[\forall A \hspace{1.5mm} \forall B \hspace{1.5mm} (A = B) \iff (\forall x \hspace{1.5mm} (x \in A \iff x \in B))\]

Através desse axioma fica mais claro de entender duas propriedades dos conjuntos.

Deste axioma, vem a explicação do motivo de que a ordem dos elementos de um conjunto não importa. Pois dado dois conjuntos com os mesmos elementos, mas em ordem diferente (por exemplo, $X=\{a,b,c,d,e,f\}$ e o conjunto $Y=\{e,c,f,b,a,d\}$) eles ainda satisfazem a propriedade de que se $t$ pertence a um deles implica $t$ pertencer ao outro. Outro ponto interessante é que não importa se um conjunto possui elementos repetidos ele continuará igual ao que possui apenas um elemento, isto é, $X=\{a,b,d,e\}$ é igual ao $Y=\{b,a,d,a,e,b,b\}$. Ou seja, em um conjunto não importa a ordem e nem as repetições de elementos.

\textbf{Axioma da Existencia do Conjunto Vazio:} Diremos que no nosso universo ($\mathcal{U}$), existe um conjunto tal que ele não contém ninguém, ou seja, ele é vazio, daí seu nome, Conjunto Vazio (denotado por $\emptyset$). O axioma é:

\[\exists A \hspace{1.5mm} \forall x \hspace{1.5mm} \neg\hspace{0.5mm} (x \in A)\]

$\qquad$

\textbf{Unicidade do Conjunto Vazio}

Podemos provar a unicidade do conjunto vazio a partir dos dois axiomas acima. Suponhamos que existam dois conjuntos ($A$ e $B$) com a propriedade do conjunto vazio, assim utilizando o axioma da Extensão concluíremos que eles são iguais, seja $t$ arbitrário:

\begin{center}
  \begin{landscape}
  \AxiomC{$\forall a  \forall b  (a = b) \iff (\forall x  (x \in a \iff x \in b))$}
  \UnaryInfC{$(A = B) \iff (\forall x  (x \in A \iff x \in B))$}
  \AxiomC{$t \in A $}
  \AxiomC{}
  \RightLabel{\scriptsize $1$}
  \UnaryInfC{$\forall x \neg (x \in A)$}
  \UnaryInfC{$\neg (t \in A)$}
  \BinaryInfC{$\perp$}
  \UnaryInfC{$t \in B$}
  \AxiomC{$t \in B$}
  \AxiomC{}
  \RightLabel{\scriptsize $1$}
  \UnaryInfC{$\forall x \neg (x \in B)$}
  \UnaryInfC{$\neg (t \in B)$}
  \BinaryInfC{$\perp$}
  \UnaryInfC{$t \in A$}
  \RightLabel{\scriptsize $\iff I_1$}
  \BinaryInfC{$t \in A \iff t \in B$}
  \UnaryInfC{$\forall x  (x \in A \iff x \in B)$}
  %\RightLabel{\scriptsize $\to E_4$}
  \BinaryInfC{A=B}
  \DisplayProof
  \end{landscape}
\end{center}

\textbf{Axioma do Par:} Este axioma nos diz que para todos os conjuntos $A$ e $B$, existe um conjunto conjunto que é $\{A,B\}$. Ou seja,

\[\forall A \hspace{1.5mm} \forall B \hspace{1.5mm} \exists C \hspace{1.5mm} \forall x \hspace{1.5mm} (x \in C \leftrightarrow x = A \vee x = B)\]

Vale ressaltar que se $A=B$, teremos $\{A,B\}=\{A,A\}=\{A\}$. A aplicação sucessiva deste axioma nos permite criar uma infinidade de conjuntos finitos. Por exemplo, $A=\emptyset$ e seja $B=\emptyset$, assim teremos $\{\emptyset\}$, sendo $B=\{\emptyset\}$, teremos agora $\{\emptyset,\{\emptyset\}\}$, agora fazendo $A=\{\emptyset\}$, teremos $\{\{\emptyset\}\}$.

Não pretendemos nos aprofundar mais nos axiomas de conjuntos, dado que eles utilizarão conceitos abordados futuramente, nos capítulos de Relações, Funções e Indução.

Mas como se pode ver em Lean - Logic and Proof, podemos reduzir uma grande gama de coisas a conjuntos, assim podemos tratá-las na Teoria dos Conjuntos. Para saber mais sobre Teoria dos Conjuntos, consulte \href{https://www.ime.usp.br/~fajardo/Conjuntos.pdf}{Teoria dos Conjuntos - USP}.

\section{Diagrama de Venn}
A maneira mais simples de entender a Teoria de Conjuntos, talvez seja o Diagrama de Venn. Criado por John Venn em 1880, esse sistema de representar graficamente conjuntos auxilia imensamente quem está começando a aprender esse assunto, principalmente para entender sobre a parte inicial de notações e definições. Basicamente, ele consiste em representar num plano, o universo $\mathcal U$ como sendo um retângulo e cada conjunto $A,B,...$ como uma curva fechada simples (geralmente, círculo).

\subsection{Para 1 ou 2 conjuntos}
Começando com a ideia mais simples, a imagem abaixo representa em vermelho o conjunto $A$ dentro do universo $\mathcal U$:

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_01.pdf}
  \caption{Conjunto $A$ dentro de $\mathcal U$}
  \label{fig:sets_03_01}
\end{figure}

Já sobre o conjunto complementar $\overline A$, ele simplesmente é a parte que está no retângulo, mas não está no círculo, justamente o que não estava em vermelho na figura anterior.

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_02.pdf}
  \caption{Conjunto complementar $\overline A$}
  \label{fig:sets_03_02}
\end{figure}

Para representar que um elemento pertence ao conjunto $A$, simplesmente colocamos ele dentro do espaço delimitado pelo círculo que representa o conjunto, e para representar que um elemento nāo pertence ao conjunto $A$, fazemos o inverso.

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_03.pdf}
  \caption{$a \in A$ e $b \notin A$}
  \label{fig:sets_03_03}
\end{figure}

Quando vamos representar mais de um conjunto em um diagrama de Venn, devemos necessariamente ter todas as possíveis relações, mas o que isso significa? Por exemplo, quando temos $2$ conjuntos $A$ e $B$, significa que devemos ter $4$ regiões representando respectivamente: elementos que pertencem somente a $A$, elementos que pertencem somente a $B$, elementos que pertencem a $A$ e $B$ simultaneamente e elementos que não pertencem a nenhum dos conjuntos. Precisamos disso, para que tudo que provarmos para dois conjuntos $A$ e $B$ possa ser generalizado para dois conjuntos quaisquer, independente do problema e da situação que estamos estudando.

\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.29]{figures/sets/fig_sets_03_04.pdf}
  \caption{Conjuntos $A$ e $B$}
  \label{fig:sets_03_04}
\end{figure}

Utilizando esse artifício, podemos representar todas as definições de intersecçāo, uniāo e diferença de $2$ conjuntos, introduzidas na seçāo anterior. Veja:

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.29]{figures/sets/fig_sets_03_05.pdf}
  \caption{Intersecção $A \cap B$}
  \label{fig:sets_03_05}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.29]{figures/sets/fig_sets_03_06.pdf}
  \caption{União $A \cup B$}
  \label{fig:sets_03_06}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_07.pdf}
  \caption{Diferença $A \setminus B$}
  \label{fig:sets_03_07}
\end{figure}

\FloatBarrier

Todavia, isso ainda não permite fazer tudo que desejamos. Se quisermos representar que $A \subseteq B$, a ideia inicial seria colocar o círculo $A$ dentro do círculo $B$, quebrando o rigor de manter todas as possíveis relações, pois não teremos uma região para representar os elementos que pertecem somente a $A$. Então, como resolver esse problema? Representamos os conjuntos $A$ e $B$ da mesma forma que anteriormente e também escrevemos o símbolo do conjunto vazio $\emptyset$ na região dos elementos que pertencem somente a $A$. Assim, só existem elementos no conjunto $A$ que estão na região $A\cap B$, ou seja, se um elemento está em $A$, como consequência ele está em $B$, exatamente a definição de $A \subseteq B$.

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_08.pdf}
  \caption{Subconjunto $A \subseteq B$}
  \label{fig:sets_03_08}
\end{figure}

É inegável que para muitos exemplos isso se torna inviável, principalmente quando o único objetivo é fazer uma ilustração matemática do problema, como por exemplo: tomamos o universo $\mathcal U$ como a fauna do nosso planeta, nele temos dois conjuntos $A$ de humanos e $B$ de mamíferos. É previamente conhecido que todos os humanos são mamíferos, falando de outra forma, que $A \subseteq B$. Logo, para representar um problema que envolva esses elementos, podemos utilizar o \textbf{Diagrama de Euler}, similar ao Diagrama de Venn, com a diferença de que não é necessário mostrar todas as possíveis relações, mas apenas aquelas específicas do problema retratado. E assim, fazemos exatamente o que tinha sido proposto no parágrafo anterior, colocar o círculo $A$ dentro do círculo $B$.

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_09.pdf}
  \caption{Diagrama de Euler $A \subseteq B$}
  \label{fig:sets_03_09}
\end{figure}

\subsection{Para 3 conjuntos ou mais}
Já foi bastante falado sobre Diagrama de Venn, mas nem chegamos a trabalhar com mais de $2$ conjuntos, o que é importante, dado que a Teoria de Conjuntos não se resume a $A$ e $B$. Mas antes de partirmos para mais conjuntos, vamos pensar numa generalização de quantas regiões diferentes devemos ter para que o diagrama seja um Diagrama de Venn. Dado $n$ conjuntos diferentes, tomamos um elemento qualquer $x$, e para cada um dos $n$ conjuntos existem duas possibilidades: $x \in $ conjunto e $x \notin $ conjunto. Logo, concluímos que existem $\underbrace{\begin{matrix} 2\cdot2\cdots2\cdot2\end{matrix}}_{n} = 2^n$ possibilidades de pertencimento de $x$ nos conjuntos, equivalente à dizer que existem $2^n$ regiões diferentes. Isso bate perfeitamente com o caso anterior pra $n=2$, pois vimos que era necessário ter $4=2^2$ regiões diferentes.

Agora, com $3$ conjuntos $A$, $B$ e $C$, o número de regiões diferentes é $2^3=8$, mas como iremos representá-las? A primeira ideia que vem a cabeça é adicionar um círculo representando o conjunto $C$ no diagrama da figura $\ref{fig:sets_03_04}$, intersectando as regiões já existentes, resultando na figura $\ref{fig:sets_03_10}$.

$\qquad$

Fazendo uma rápida contagem, obtemos $8$ regiões diferentes, exatamente como deve ser (lembrete: A região fora dos conjuntos mas dentro do universo $\mathcal U$, também é considerada na contagem). E da mesma forma que representamos intersecção, união e diferença de conjuntos anteriormente, também podemos representar com $3$ conjuntos, veja nas figuras a seguir:

\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_10.pdf}
  \caption{Conjuntos $A$, $B$ e $C$}
  \label{fig:sets_03_10}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_11.pdf}
  \caption{Intersecção $A \cap B \cap C$}
  \label{fig:sets_03_11}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_12.pdf}
  \caption{União $A \cup B \cup C$}
  \label{fig:sets_03_12}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_13.pdf}
  \caption{Diferença $A \setminus (B \cup C)$}
  \label{fig:sets_03_13}
\end{figure}

\newpage

$\qquad$

$\qquad$

Sendo ganancioso e indo além, podemos querer representar $4$ conjuntos, adicionando o conjunto $D$. E igual o caso anterior, só temos que adicionar mais um círculo representando o conjunto $D$ e, dado que antes obtemos um triângulo de círculos, dessa vez iremos ter uma quadrado de cícurlos, correto?

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_14.pdf}
  \caption{4 Conjuntos}
  \label{fig:sets_03_14}
\end{figure}

\textbf{ERRADO!} Se você é um leitor observador, já deve ter notado que esse diagrama não possui as $2^4=16$ regiões diferentes necessárias, mas somente $14$. Não existem regiões que representam os elementos que pertencem ao mesmo tempo aos conjuntos $A$ e $D$, mas não pertencem ao conjunto $B$ e nem ao $C$, e o inverso disso, ou seja, os elementos que pertencem ao mesmo tempo aos conjuntos $B$ e $C$, mas não pertencem ao conjunto $A$ e nem ao $D$.

É válido ressaltar que é impóssível utilizar $4$ círculos pra representar $4$ conjuntos em um diagrama de Venn. Contudo, existem diagramas de Venn pra $4$ conjuntos, e antes de ler o próximo parágrafo, pegue uma folha e tente encontrar possíveis maneiras dessa representação. Dica: Não se abstenha de utilizar formas bem diferenciadas.

Se você conseguiu, parabéns. Saiba que existem diversas maneiras, como por exemplo: $4$ elipses ou $3$ círculos e uma forma semelhante à metade de uma rosquinha. Fique a vontade para pesquisar na internet essas e outras maneiras de representação. Ainda assim, é relevante mostrar pelo menos uma delas aqui, e escolhemos a da figura $\ref{fig:sets_03_15}$, onde cada conjunto é representado por um meio círculo junto com um retângulo, resultando em algo muito semelhante a dois corações.

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_15.pdf}
  \caption{Diagrama em formato de $2$ corações}
  \label{fig:sets_03_15}
\end{figure}

Podemos continuar e encontrar representações para $5$ ou mais conjuntos, as quais vão ficando cada vez mais complicadas. Porém, como nosso principal objetivo é utilizar visualizações gráficas para facilitar o aprendizado em Teoria de Conjuntos, a partir do momento que isso vem a se tornar complicado, perde totalmente a utilidade. Por esse motivo, vamos parar em $4$ conjuntos, mas se a curiosidade for grande, procure aprender mais sobre esse assunto.

\subsection{Aplicações}
A mais importante e útil das aplicações é justamente demonstrar propriedades da Teoria de Conjuntos. Se fosse solicitado para você leitor demonstrar as propriedades a seguir, somente com o que aprendeu até agora, já conseguiria utilizar o Diagrama de Venn para demonstrá-las. Apesar de parecer complicado, é incrivelmente simples, veja:

\textbf{Exemplo 1:} Demonstre que $A \setminus B = A \cap \overline B$.

\textbf{Resposta:} Primeiramente, vamos fazer o Diagrama de Venn desses dois conjuntos e enumerar as $4$ regiões, conforme a figura $\ref{fig:sets_03_16}$.

\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_16.pdf}
  \caption{Regiões $1$, $2$, $3$ e $4$}
  \label{fig:sets_03_16}
\end{figure}

Assim, temos que $A=\{1,2\}$, $B=\{2,3\}$, $\overline A=\{3,4\}$ e $\overline B=\{1,4\}$. Utilizando esse valores, podemos calcular $A \setminus B$ e $A \cap \overline B$, conforme abaixo:

\begin{equation*}
\begin{aligned}
  A \setminus B &= \{1,2\} \setminus \{2,3\} = \{1\}\\
  A \cap \overline B &= \{1,2\} \cap \{1,4\} = \{1\}
\end{aligned}
\end{equation*}

Portanto, concluímos que $A \setminus B = A \cap \overline B$.

\textbf{Exemplo 2:} Demonstre que $(A \setminus B) \cup (B \setminus A) = (A \cup B) \setminus (A \cap B)$.

\textbf{Resposta:} Utilizando o mesmo Diagrama de Venn e a mesma numeração de regiões do exemplo anterior, temos:

\begin{equation*}
\begin{aligned}
  A \setminus B &= \{1,2\} \setminus \{2,3\} = \{1\}\\
  B \setminus A &= \{2,3\} \setminus \{1,2\} = \{3\}\\
  A \cup B &= \{1,2\} \cup \{2,3\} = \{1,2,3\}\\
  A \cap B &= \{1,2\} \cap \{2,3\} = \{2\}\\
  (A \setminus B) \cup (B \setminus A) &= \{1\} \cup \{3\} = \{1,3\}\\
  (A \cup B) \setminus (A \cap B) &= \{1,2,3\} \setminus \{2\} = \{1,3\}
\end{aligned}
\end{equation*}

Portanto, concluímos que $(A \setminus B) \cup (B \setminus A) = (A \cup B) \setminus (A \cap B)$.
\newline
É possível responder essas questões somente utilizando o diagrama e pintando as regiões, mas a enumeração torna o processo mais fácil.

$\qquad$

Outra aplicação interessante, muito recorrente em testes de lógica e vestibulares, é tentar interpretar problemas da vida real com conjuntos, conforme no exemplo a seguir:

\textbf{Exemplo 3:} Em uma sala de aula do Ensino Fundamental com $40$ alunos, a professora Ana perguntou quem gostava de matemática e quem gostava de português. Ela obteve os seguintes dados:

\begin{itemize}
\item $21$ alunos gostam de matemática
\item $17$ alunos gostam de português
\item $9$ alunos não gostam de nenhuma das matérias
\end{itemize}

Quantos alunos gostam de ambas as matérias?

$\qquad$

\textbf{Resposta:} Vamos utilizar um Diagrama de Venn para dois conjuntos, onde um conjunto representa os alunos que gostam de matemática e o outro representa os que gostam de português.
Dado que $9$ alunos não gostam de nenhuma das matérias e temos $40$ alunos na sala, então $40-9=31$ alunos pertencem a pelo menos um dos conjuntos, ou seja, gostam de matemática ou português.

Como $21$ gostam de matemática, logo $31-21=10$ gostam somente de português (região da direita) e, analogamente, como $17$ gostam de português, logo $31-17=14$ gostam somente de matemática (região da esquerda). Utilizando esses dados, vemos que ainda faltam $31-10-14=7$ alunos, justamente os que gostam de ambas as matérias (região do meio). Veja abaixo o diagrama final:

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.3]{figures/sets/fig_sets_03_17.pdf}
  \caption{Diagrama para Matemática e Português}
  \label{fig:sets_03_17}
\end{figure}

Apesar do estudo de conjuntos com Diagrama de Venn ser fácil, simples e útil, como já comentado anteriormente, é difícil para trabalhar com muitos conjuntos, além das provas utilizando esse recurso não terem um grau de formalidade muitas vezes requerido pelos matemáticos. Devido a esse fato, iremos estudar nas próximas seções outras maneiras de lidar com Teoria dos Conjuntos, como provas matemáticas formais, dedução natural, cálculo em conjuntos e é claro, utilizando o Lean.

\section{Prova de Teoremas}

Nesta seção iremos tratar de formalizar definições e Teoremas. Ao contrário da seção $5.2$, onde o foco era transmitir a notação e uma ideia geral dos conceitos.

\subsection{Prova Matemática Tradicional}

As provas matemáticas usuais, geralmente, mesclam a linguagem ``escrita'' comum com algumas notações da área. Assim, para um leitor pode ficar mais fácil de entender a prova do Teorema, já que não haverá apenas termos técnicos, no entanto, se o autor não tomar cuidado ele poderá abrir espaço para gerar conflitos, isto é, dupla interpretação, esquecer de provar algo, omitir passagens ``triviais'' (para o autor, mas para os leitores, mesmo que sejam matemáticos fica difícil de entender). Assim, tome muito cuidado ao fazer uma prova deste tipo, mas nunca a ignore, pois quando dominá-la, poderá ser mais fácil transmitir seu conhecimento a leigos ou iniciantes na matenática, do que provas que utilizam apenas termos técnicos.

Procure, sempre que necessário, usar conectivos como: ``logo'', ``então'', ``assim'', ``portanto'', mas nunca se esqueça, nunca use apenas um, procure variar o máximo possível entre os conectivos, pois isto deixa o texto mais atraente para o leitor.

\qquad

\textbf{Exemplo 1:} $A \cap B = B \cap A$

Suponha que tenhamos um $t$ arbitrário e, $t \ in A \cap B$, que é a mesma coisa que $t \in A \wedge t\in B$, que equivale a $t \in B \and t \in A$. Logo, $t \in B \cap A$. Portanto, $A \cap B = B \cap A$.

\qquad

\subsection{Dedução Natural}

Utilizar Dedução Natural para provar um Teorema é melhor, pois nos dá mais confiança e controle para vermos cada passo que estamos executando na prova, no entanto, é necesário que o leitor tenha alguma familiaridade com este tipo de demonstração e  que conheça algumas definições sobre conjuntos em FOL.

\qquad

\textbf{Exemplo 1:} $A \cap B = B \cap A$

Como nossa prova é muito extensa para caber em um papel iremos modularizar ela.

Abaixo segue a prova de $ t \in A \cap B \rightarrow t \in B \cap A $, para um $t$ arbitrário. Estaremos usando a definição de interseção em FOL, coso não se recorde dela, releia a parte ``Definições''', da seção ``Fundamentos''.
    
    $(i)$    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap B$}
        \AxiomC{$\forall x (x \in A \cap B \iff x \in A \wedge x \in B)$}
        \UnaryInfC{$t \in A \cap B \iff t \in A \wedge t \in B$}
        \BinaryInfC{$t \in A \wedge t \in B$}
        \UnaryInfC{$ t \in A$}
        \DisplayProof
    \end{center}
    
    \qquad
    
    $(ii)$
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap B$}
        \AxiomC{$\forall x (x \in A \cap B \iff x \in A \wedge x \in B)$}
        \UnaryInfC{$t \in A \cap B \iff t \in A \wedge t \in B$}
        \BinaryInfC{$t \in A \wedge t \in B$}
        \UnaryInfC{$ t \in B$}
        \DisplayProof
    \end{center}
    
    \qquad
 
De $(i)$ e $(ii)$, podemos obter $t \in A \cap B \rightarrow t \in B \cap A$:

$(iii)$
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap B$}
        \AxiomC{$(ii)$}
        \BinaryInfC{$t \in B$}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap B$}
        \AxiomC{$(i)$}
        \BinaryInfC{$t \in A$}
        \BinaryInfC{$t \in B \wedge t \in A$}
        \AxiomC{$\forall x (x \in B \cap A \iff x \in B \wedge x \in A)$}
        \UnaryInfC{$t \in B \cap A \iff t \in B \wedge t \in A$}
        \BinaryInfC{$t \in B \cap t \in A$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap B \rightarrow t \in B \cap A$}
        \DisplayProof
    \end{center}


Agora iremos provar que $ t \in B \cap A \rightarrow t \in A \cap B $, $t$ arbitrário.
    
    $(iv)$    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in B \cap A$}
        \AxiomC{$\forall x (x \in B \cap A \iff x \in B \wedge x \in A)$}
        \UnaryInfC{$t \in B \cap A \iff t \in B \wedge t \in A$}
        \BinaryInfC{$t \in B \wedge t \in A$}
        \UnaryInfC{$ t \in B$}
        \DisplayProof
    \end{center}
    
    \qquad
    
    $(v)$
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in B \cap A$}
        \AxiomC{$\forall x (x \in B \cap A \iff x \in B \wedge x \in A)$}
        \UnaryInfC{$t \in B \cap A \iff t \in B \wedge t \in A$}
        \BinaryInfC{$t \in B \wedge t \in A$}
        \UnaryInfC{$ t \in A$}
        \DisplayProof
    \end{center}
    
    \qquad
 
De $(iv)$ e $(v)$, podemos obter $t \in B \cap A \rightarrow t \in A \cap B$:

$(vi)$
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in B \cap A$}
        \AxiomC{$(v)$}
        \BinaryInfC{$t \in A$}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in B \cap A$}
        \AxiomC{$(iv)$}
        \BinaryInfC{$t \in B$}
        \BinaryInfC{$t \in A \wedge t \in B$}
        \AxiomC{$\forall x (x \in A \cap B \iff x \in A \wedge x \in B)$}
        \UnaryInfC{$t \in A \cap B \iff t \in A \wedge t \in B$}
        \BinaryInfC{$t \in A \cap t \in B$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in B \cap A \rightarrow t \in A \cap B$}
        \DisplayProof
    \end{center}
    
    De $(iii)$ e $(v)$, aplicando a regra do ``e'' introdução, teremos $ (t \in A \cap B \rightarrow t \in B \cap A) \wedge (t \in B \cap A \rightarrow t \in A \cap B) $, que é equivalente a , $t \in A \cap B \iff t \in B \cap A $.
 
 \qquad
 
   Dado que $t$ é arbitrário, podemos aplicar a regra do ``para todo introdução'', $\forall x (x \in A \cap B \iff x \in B \cap A)$.
 
 \qquad
 
   Portanto, aplicando o Axioma da Extensão teremos $A \cap B = B \cap A$.
   
  \qquad
  
    Resolvemos não explicitar em Dedução Natural o final da prova, pois seria apenas reescrever o que os axiomas e regras definidas em capítulos anteriores falavam, e como uma página é menor que um quadro e o Latex tem certas limitações (que papel e canta não possuem), seria inviável explicitar a última parte.

\qquad

\section{Conjuntos em Lean}
Embora na teoria axiomática dos conjuntos se considere conjuntos de objetos distintos, em matemática é mais comum considerar subconjuntos de algum domínio fixo ($\mathcal U $). É assim que os conjuntos são tratados em Lean. Para qualquer dado do tipo {\fontencoding{U}\fontfamily{cmtt}\selectfont U}, Lean nos retorna um novo dado tipo {\fontencoding{U}\fontfamily{cmtt}\selectfont set U}, que consiste no conjunto dos elementos de {\fontencoding{U}\fontfamily{cmtt}\selectfont U}. Assim, por exemplo, podemos raciocinar sobre conjuntos de números naturais, conjuntos de números inteiro ou conjuntos de pares de números naturais.

\subsection{Notações}
O lean possui uma biblioteca padrão para lidar com conjuntos chamada {\fontencoding{U}\fontfamily{cmtt}\selectfont set} e, sempre que formos utilizar um comando que pertence a ela, é necessário escrever {\fontencoding{U}\fontfamily{cmtt}\selectfont set.comando}. Entretanto, pra facilitar nossa vida, podemos escrever {\fontencoding{U}\fontfamily{cmtt}\selectfont open set} no início do código, o que permite escrevermos somente {\fontencoding{U}\fontfamily{cmtt}\selectfont comando}, e o lean já entende que ele pertence a biblioteca set.

Além disso, para trabalharmos com conjuntos, também é essencial definirmos um tipo {\fontencoding{U}\fontfamily{cmtt}\selectfont U} e sabermos utilizar conjuntos e elementos desse tipo. Para isso, utilizamos o código abaixo:

\begin{lstlisting}
open set

variable {U : Type}
variables A B C : set U
variable x : U \end{lstlisting}

Temos aqui uma pequena lista de como se representa os principais caractéres da parte de conjuntos em Lean:

\begin{itemize}
  \item $\in$ $\rightarrow$ $\backslash$in

  \item $\notin$ $\rightarrow$ $\backslash$notin

  \item $\subset$ $\rightarrow$ $\backslash$subset

  \item $\subseteq$ $\rightarrow$ $\backslash$sub

  \item $\emptyset$ $\rightarrow$ $\backslash$empty

  \item $\cup$ $\rightarrow$ $\backslash$un \ ou \ $\backslash$cup \ ou \ $\backslash$union

  \item $\cap$ $\rightarrow$ $\backslash$i \ ou \ $\backslash$cap \ ou \ $\backslash$intersection
\end{itemize}

Obs$^{1}$.: O conjunto universal é denotado {\fontencoding{U}\fontfamily{cmtt} \selectfont univ}.

Obs$^{2}$.: O complementar de um conjunto é denotado com um símbolo de subtração antes dele: $-A$

Podemos ver alguns exemplos abaixo:
\begin{lstlisting}
open set
variable {U : Type}
variables A B C : set U
variable x : U

#check x ∈ A
#check A ∪ B
#check B \ C
#check C ∩ A
#check -C
#check ∅ ⊆ A
#check B ⊆ univ \end{lstlisting}

Noções básicas da teoria dos conjuntos são definidas na biblioteca principal do Lean, mas teoremas e notações adicionais que iremos utilizar nesse capítulo, estão disponíveis em uma biblioteca auxiliar que é carregada com o comando
{\fontencoding{U}\fontfamily{cmtt} \selectfont import data.set}, o qual deve aparecer no início do arquivo.

\begin{lstlisting}
import data.set
open set
variable {U : Type}
variables A B C : set U
variable x : U \end{lstlisting}

A partir desse momento, para evitar repetição, iremos omitir as $4$ primeiras linhas do código, no entanto \textbf{você deve lembrar que elas existem para seu código funcionar.} Já sobre a linha $5$, não é necessário escrever nos próximos exemplos, pois sempre iremos nos referenciar a um elemento do tipo{\fontencoding{U}\fontfamily{cmtt} \selectfont U}, dentro de {\fontencoding{U}\fontfamily{cmtt}\selectfont example, lemma} ou {\fontencoding{U}\fontfamily{cmtt}\selectfont theorem}.

\subsection{Primeiros Passos}

Relembrando a definição de subconjunto, podemos utilizar o template abaixo para mostrar que o conjunto $A$ é um subconjunto de $B$:

\begin{lstlisting}
example : A ⊆ B :=
assume x : U,
assume h : x ∈ A,
show x ∈ B, from sorry \end{lstlisting}

Obs: Na linha $2$ poderíamos ter escrito somente {\fontencoding{U}\fontfamily{cmtt}\selectfont assume x}, pois já inferiria que {\fontencoding{U}\fontfamily{cmtt}\selectfont x} é do tipo {\fontencoding{U}\fontfamily{cmtt}\selectfont U}.

Já para mostrar que $A$ e $B$ são iguais, temos dois comandos diferentes: {\fontencoding{U}\fontfamily{cmtt}\selectfont eq\_of\_subset\_of\_subset} e {\fontencoding{U}\fontfamily{cmtt}\selectfont ext}.

\textbf{eq\_of\_subset\_of\_subset:} Ele funciona interpretando a seguinte expressão $(A \subseteq B \wedge B \subseteq A) \Rightarrow A=B$, ou seja, obtém a equivalência dos conjuntos a partir do fato de que o primeiro é subconjunto do segundo, e vice-vera. Veja o código:

\begin{lstlisting}
example : A = B :=
eq_of_subset_of_subset
(assume x,
  assume h : x ∈ A,
  show x ∈ B, from sorry)
(assume x,
  assume h : x ∈ B,
  show x ∈ A, from sorry) \end{lstlisting}

\textbf{ext:} É uma sigla para ``extensionality", ou seja, extensionalidade. Matemáticamente, isso representa a expressão $\forall x \ (x \in A \leftrightarrow x \in B) \Rightarrow A=B$. Veja o código:

\begin{lstlisting}
example : A = B :=
ext (assume x, iff.intro
(assume h : x ∈ A,
  show x ∈ B, from sorry)
(assume h : x ∈ B,
  show x ∈ A, from sorry)) \end{lstlisting}

Além disso, o Lean possui interpretação ambígua para regras de união, interseção e outras operações em conjuntos que são consideradas “definições”. Isso significa que as expressões $x$ $\in$ $A$ $\cap$ $B$ e $x$ $\in$ $A$ $\wedge$ $x$ $\in$ $B$ possuem a mesma interpretação no Lean. Isso também é válido para outras construções em conjuntos, como: $x$ $\in$ $A$ $\backslash $ $B$ e $x$ $\in$ $A$ $\wedge$ $\neg$ $(x$ $\in$ $B)$. O termo $\neg$ $(x$ $\in$ $B)$ é somente outra forma de escrever $x$ $\notin$ $B$. Abaixo são apresentadas algumas aplicações dessas interpretações:

\begin{lstlisting}
example : ∀ x, x ∈ A → x ∈ B → x ∈ A ∩ B :=
assume x,
assume h₁ : x ∈ A,
assume h₂ : x ∈ B,
show x ∈ A ∩ B, from and.intro h₁ h₂

example : A ⊆ A ∪ B :=
assume x,
assume h : x ∈ A,
show x ∈ A ∪ B, from or.inl h

example : ∅ ⊆ A  :=
assume x,
assume h : x ∈ (∅ : set U),
show x ∈ A, from false.elim h \end{lstlisting}

Observe no último exemplo a necessidade de usar a notação {\fontencoding{U}\fontfamily{cmtt} \selectfont ($\emptyset$ : set U)}, dizendo ao nosso provador que o $\emptyset$ é um conjunto de{\fontencoding{U}\fontfamily{cmtt}
\selectfont U}. Isso acontece pois ele não consegue inferir que tipo é o conjunto vazio, dado que por definição, esse conjunto existe em qualquer universo, ou seja, pode ser de qualquer tipo.

Opcionalmente, podemos usar alguns teoremas da biblioteca {\fontencoding{U}\fontfamily{cmtt}
\selectfont data.set}, projetados especificamente para uso em conjuntos:

\begin{lstlisting}
example : ∀ x, x ∈ A → x ∈ B → x ∈ A ∩ B :=
assume x,
assume h : x ∈ A,
assume g : x ∈ B,
show x ∈ A ∩ B, from mem_inter h g

example : A ⊆ A ∪ B :=
assume x,
assume h : x ∈ A,
show x ∈ A ∪ B, from mem_union_left B h

example : ∅ ⊆ A  :=
assume x,
assume h : x ∈ ∅,
show x ∈ A, from absurd h (not_mem_empty x) \end{lstlisting}

Lembre-se que o comando{\fontencoding{U}\fontfamily{cmtt}
\selectfont absurd} pode ser usado para provar qualquer fato a partir de duas hipóteses contrárias: $h_1$ : $P$ e $h_2$ : $\neg$ $P$.

Aqui, o teorema {\fontencoding{U}\fontfamily{cmtt}
\selectfont not\_mem\_empty x} significa $x$ $\notin$ $\emptyset$. Para ver a declaração de teoremas disponíveis, utilize o comando{\fontencoding{U}\fontfamily{cmtt}
\selectfont \#check}:
\begin{lstlisting}
#check @mem_inter
#check @mem_of_mem_inter_left
#check @mem_of_mem_inter_right
#check @mem_union_left
#check @mem_union_right
#check @mem_or_mem_of_mem_union
#check @not_mem_empty \end{lstlisting}

Neste caso, o símbolo{\fontencoding{U}\fontfamily{cmtt}
\selectfont @} (arroba) impede que ele tente preencher argumentos implícitos automaticamente, forçando-o a exibir a declaração completa do teorema.

Já que podemos relacionar conjuntos com suas definições lógica, isso auxilia a comprovação de certas relações entre conjuntos:

\begin{lstlisting}
example : A \ B ⊆ A :=
assume x,
assume h : x ∈ A \ B,
show x ∈ A, from and.left h

example : A \ B ⊆ -B :=
assume x,
assume h : x ∈ A \ B,
have g : x ∉ B, from and.right h,
show x ∈ -B, from g \end{lstlisting}

Novamente, é possível usar versões dos teoremas projetados especificamente para conjuntos:

\begin{lstlisting}
example : A \ B ⊆ A :=
assume x,
assume h : x ∈ A \ B,
show x ∈ A, from mem_of_mem_diff h

example : A \ B ⊆ -B :=
assume x,
assume h : x ∈ A \ B,
have g : x ∉ B, from not_mem_of_mem_diff h,
show x ∈ -B, from g \end{lstlisting}

Como o Lean tem que desenvolver definições, ele pode acabar se confundindo às vezes. Por exemplo, na prova a seguir, se você subtituir a última linha por {\fontencoding{U}\fontfamily{cmtt}\selectfont sorry}, ele terá problemas tentando entender que você quer que ele desenvolva o símbolo de subconjunto:

\begin{lstlisting}
example : A ∩ B ⊆ B ∩ A :=
assume x,
assume h : x ∈ A ∩ B,
have h₁ : x ∈ A, from and.left h,
have h₂ : x ∈ B, from and.right h,
and.intro h₂ h₁ \end{lstlisting}

Uma solução alternativa é usar o comando {\fontencoding{U}\fontfamily{cmtt}\selectfont show}. Na maioria das vezes, fornecer informações adicionais para o Lean pode ser útil. Outra solução é nomear um teorema, o que leva o nosso provador a usar um método um pouco diferente de processar a prova, corrigindo o problema como um efeito colateral.(Substituindo a parte posterior ao {\fontencoding{U}\fontfamily{cmtt}\selectfont from} na linha 6 ou a linha 13 inteira por ``{\fontencoding{U}\fontfamily{cmtt}\selectfont sorry}" o provedor não localiza problemas).

\begin{lstlisting}
example : A ∩ B ⊆ B ∩ A :=
assume x,
assume h : x ∈ A ∩ B,
have h₁ : x ∈ A, from and.left h,
have h₂ : x ∈ B, from and.right h,
show x ∈ B ∩ A, from and.intro h₂ h₁

theorem my_example : A ∩ B ⊆ B ∩ A :=
assume x,
assume h : x ∈ A ∩ B,
have h₁ : x ∈ A, from and.left h,
have h₂ : x ∈ B, from and.right h,
show x ∈ B ∩ A, from and.intro h₂ h₁ \end{lstlisting}

\section{Propriedades}

A seguir teremos algumas propriedades e provas, utilizando várias maneiras vistas anteriormente neste capítulo.

\begin{enumerate}
\item{\textbf{Básicas}}
\begin{itemize}
\item $A \cap A = A$

\textbf{Prova:}
    
    Se não se lembra da definição de interceção em FOL dada na seção "Fundamentação", sugerimos fortemente que releia a parte "Definições"que se encontra na seção mencionada.
    
    $(i)$ Abaixo segue uma prova de $ t \in A \cap A \rightarrow t \in A $, onde $t$ é arbitrário.
    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap A$}
        \AxiomC{$\forall x (x \in A \cap A \iff x \in A \wedge x \in A)$}
        \UnaryInfC{$t \in A \cap A \iff t \in A \wedge t \in A$}
        \BinaryInfC{$t \in A \wedge t \in A$}
        \UnaryInfC{$ t \in A$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap A \rightarrow t \in A $}
        \DisplayProof
    \end{center}
        
    $(ii)$ Provaremos que $t \in A \rightarrow t \in A \cap A$ :
    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$ t \in A$}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$ t \in A$}
        \BinaryInfC{$t \in A \wedge t \in A$}
        \AxiomC{$\forall x (x \in A \cap A \iff x \in A \wedge x \in A)$}
        \UnaryInfC{$t \in A \cap A \iff t \in A \wedge t \in A$}
        \BinaryInfC{$t \in A \cap A$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \rightarrow t \in A \cap A$}
        \DisplayProof
    \end{center}
    
   De $(i)$ e $(ii)$, construímos, com a regra do "e" introdução, $ (t \in A \cap A \rightarrow t \in A) \wedge (t \in A \rightarrow t \in A \cap A) $, que é equivalente a , $t \in A \cap A \iff t \in A $.
   
   Dado que $t$ é arbitrário, obtemos $\forall x (x \in A \cap A \iff x \in A)$.
   
   Assim, aplicando o Axioma da Extensão temos $A \cap A = A$.

\qquad

\item $A \cup A = A$

\textbf{Prova:}
    
$(i)$ Abaixo há a prova de $ t \in A \cup A \rightarrow t \in A $, para um $t$ arbitrário.
    
\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A \cup A$}
    \AxiomC{$\forall x (x \in A \cup A \iff x \in A \vee t \in A)$}
    \UnaryInfC{$t \in A \cup A \iff t \in A \vee t \in A$}
    \BinaryInfC{$t \in A \vee t \in A$}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$ t \in A$}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$ t \in A$}
    \RightLabel{\scriptsize $2$}
    \TrinaryInfC{$t \in A$}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A \cup A \rightarrow t \in A $}
    \DisplayProof
\end{center}
        
$(ii)$ Seja $t$ arbitrário, iremos construir uma prova para $ t \in A \rightarrow t \in A \cup A$ :

\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$ t \in A$}
    \UnaryInfC{$ t \in A \vee t \in A$}
    \AxiomC{$\forall x (x \in A \cup A \iff x \in A \vee t \in A)$}
    \UnaryInfC{$t \in A \cup A \iff t \in A \vee t \in A$}
    \BinaryInfC{$t \in A \cup A$}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A \rightarrow t \in A \cup A$}
    \DisplayProof
\end{center}
    
De $(i)$ e $(ii)$, concluímos que $ (t \in A \cup A \rightarrow t \in A ) \wedge (t \in A \rightarrow t \in A \cup A) $, ou seja, $t \in A \cup A \iff t \in A $.

Como $t$ é arbitrário, é permitido dizer que temos $\forall x (x \in A \cup A \iff x \in A) $.

Portanto, temos $A \cup A = A$, se aplicarmos o Axioma da Extensão no resultado obtido no parágrafo acima.
    
\qquad

\item $A \cap \mathcal U = A$

$(i)$ Abaixo segue uma prova de $ t \in A \cap \mathcal U \rightarrow t \in A $, onde $t$ é arbitrário.
    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap \mathcal U$}
        \AxiomC{$\forall x (x \in A \cap \mathcal U \iff x \in A \wedge x \in \mathcal U)$}
        \UnaryInfC{$t \in A \cap \mathcal U \iff t \in A \wedge t \in \mathcal U$}
        \BinaryInfC{$t \in A \wedge t \in \mathcal U$}
        \UnaryInfC{$ t \in A$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap \mathcal U \rightarrow t \in A $}
        \DisplayProof
    \end{center}
        
    $(ii)$ Provaremos que $t \in A \rightarrow t \in A \cap \mathcal U$ :
    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$ t \in A$}
        \AxiomC{}
        \UnaryInfC{$\top$}
        \AxiomC{$\forall x (x \in \mathcal U \iff \top)$}
        \UnaryInfC{$t \in \mathcal U \iff \top$}
        \BinaryInfC{$t \in \mathcal U$}
        \BinaryInfC{$t \in A \wedge t \in \mathcal U$}
        \AxiomC{$\forall x (x \in A \cap \mathcal U \iff x \in A \wedge x \in \mathcal U)$}
        \UnaryInfC{$t \in A \cap \mathcal U \iff t \in A \wedge t \in \mathcal U$}
        \BinaryInfC{$t \in A \cap \mathcal U$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \rightarrow t \in A \cap \mathcal U$}
        \DisplayProof
    \end{center}
    
   De $(i)$ e $(ii)$, construímos, com a regra do ``e'' introdução, $ (t \in A \cap \mathcal U \rightarrow t \in A) \wedge (t \in A \rightarrow t \in A \cap \mathcal U) $, que é equivalente a , $t \in A \cap \mathcal U \iff t \in A$.
   
   Dado que $t$ é arbitrário, obtemos $\forall x (x \in A \cap \mathcal U \iff x \in A)$.
   
   Assim, aplicando o Axioma da Extensão temos $A \cap \mathcal U = A$.

\qquad

\item $A \cup \mathcal U = \mathcal U$

\textbf{Prova:}
    
$(i)$ Abaixo há a prova de $ t \in A \cup \mathcal U \rightarrow t \in \mathcal U $, para um $t$ arbitrário.

Como a prova é muito grande, para caber na página, iremos modularizá-la.    

\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A \cup \mathcal U$}
    \AxiomC{$\forall x (x \in A \cup \mathcal U \iff x \in A \vee t \in \mathcal U)$}
    \UnaryInfC{$t \in A \cup \mathcal U \iff t \in A \vee t \in \mathcal U$}
    \BinaryInfC{$t \in A \vee t \in \mathcal U$}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$(*)$}
    \UnaryInfC{$ t \in \mathcal U$}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$ t \in \mathcal U$}
    \RightLabel{\scriptsize $2$}
    \TrinaryInfC{$t \in \mathcal U$}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A \cup \mathcal U \rightarrow t \in \mathcal U $}
    \DisplayProof
\end{center}

(*        
\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$ t \in A$}
    \AxiomC{}
    \UnaryInfC{$\top$}
    \AxiomC{$\forall x (x \in  \mathcal U \iff \top)$}
    \UnaryInfC{$t \in  \mathcal U \iff \top$}
    \BinaryInfC{$ t \in \mathcal U$}
    \BinaryInfC{$t \in A \wedge  t \in \mathcal U$}
    \UnaryInfC{$t \in \mathcal U$}
    \DisplayProof
\end{center}        
*)

\qquad

$(ii)$ Seja $t$ arbitrário, iremos construir uma prova para $ t \in \mathcal U \rightarrow t \in A \cup \mathcal U$ :

\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$ t \in \mathcal U$}
    \UnaryInfC{$ t \in A \vee t \in \mathcal U$}
    \AxiomC{$\forall x (x \in A \cup \mathcal U \iff x \in A \vee t \in \mathcal U)$}
    \UnaryInfC{$t \in A \cup \mathcal U \iff t \in A \vee t \in \mathcal U$}
    \BinaryInfC{$t \in A \cup \mathcal U$}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in \mathcal U \rightarrow t \in A \cup \mathcal U$}
    \DisplayProof
\end{center}
    
De $(i)$ e $(ii)$, concluímos que $ (t \in A \cup \mathcal U \rightarrow t \in \mathcal U ) \wedge (t \in \mathcal U \rightarrow t \in A \cup \mathcal U) $, ou seja, $t \in A \cup \mathcal U \iff t \in \mathcal U $.

Como $t$ é arbitrário, é permitido dizer que temos $\forall x (x \in A \cup \mathcal U \iff x \in \mathcal U) $.

Portanto, temos $A \cup \mathcal U = \mathcal U$, se aplicarmos o Axioma da Extensão no resultado obtido no parágrafo acima.

\qquad

\qquad

\item $A \cap \emptyset = \emptyset$

\textbf{Prova:}

$(i)$ Abaixo segue uma prova de $ t \in A \cap \emptyset \rightarrow t \in \emptyset $, onde $t$ é arbitrário.
    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap \emptyset$}
        \AxiomC{$\forall x (x \in A \cap \emptyset \iff x \in A \wedge x \in \emptyset)$}
        \UnaryInfC{$t \in A \cap \emptyset \iff t \in A \wedge t \in \emptyset$}
        \BinaryInfC{$t \in A \wedge t \in \emptyset$}
        \UnaryInfC{$ t \in \emptyset$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap \emptyset \rightarrow t \in \emptyset $}
        \DisplayProof
    \end{center}
        
    $(ii)$ Provaremos que $t \in \emptyset \rightarrow t \in A \cap \emptyset$ :
    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$ t \in \emptyset$}
        \AxiomC{$\forall x (x \in \emptyset \iff \bot)$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$ t \in \emptyset \iff \bot$}
        \BinaryInfC{$\bot$}
        \UnaryInfC{$t \in A$}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$ t \in \emptyset$}
        \BinaryInfC{$t \in A \wedge t \in A$}
        \AxiomC{$\forall x (x \in A \cap \emptyset \iff x \in A \wedge x \in \emptyset)$}
        \UnaryInfC{$t \in A \cap \emptyset \iff t \in A \wedge t \in \emptyset$}
        \BinaryInfC{$t \in A \cap \emptyset$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in \emptyset \rightarrow t \in A \cap \emptyset$}
        \DisplayProof
    \end{center}
    
   De $(i)$ e $(ii)$, construímos, com a regra do ``e'' introdução, $ (t \in A \cap \emptyset \rightarrow t \in \emptyset) \wedge (t \in \emptyset \rightarrow t \in A \cap \emptyset) $, que é equivalente a , $t \in A \cap \emptyset \iff t \in \emptyset$.
   
   Dado que $t$ é arbitrário, obtemos $\forall x (x \in A \cap \emptyset \iff x \in \emptyset)$.
   
   Assim, aplicando o Axioma da Extensão temos $A \cap \emptyset = \emptyset$.
   
\qquad

\item $A \cup \emptyset = A$

\textbf{Prova:}
    
$(i)$ Abaixo há a prova de $ t \in A \cup \emptyset \rightarrow t \in A $, para um $t$ arbitrário.

Como a prova é muito grande, para caber na página, iremos modularizá-la.    

\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A \cup \emptyset$}
    \AxiomC{$\forall x (x \in A \cup \emptyset \iff x \in A \vee t \in \emptyset)$}
    \UnaryInfC{$t \in A \cup \emptyset \iff t \in A \vee t \in \emptyset$}
    \BinaryInfC{$t \in A \vee t \in \emptyset$}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$ t \in A$}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$(*)$}
    \UnaryInfC{$ t \in A$}
    \RightLabel{\scriptsize $2$}
    \TrinaryInfC{$t \in A$}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A \cup \emptyset \rightarrow t \in A $}
    \DisplayProof
\end{center}

(*        
\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$ t \in \emptyset$}
    \AxiomC{$\forall x (x \in \emptyset \iff \bot)$}
    \UnaryInfC{$t \in \emptyset \iff \bot$}
    \BinaryInfC{$\bot$}
    \UnaryInfC{$t \in A $}
    \DisplayProof
\end{center}        
*)

\qquad

$(ii)$ Seja $t$ arbitrário, iremos construir uma prova para $ t \in A \rightarrow t \in A \cup \emptyset$ :

\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$ t \in A$}
    \UnaryInfC{$ t \in A \vee t \in \emptyset$}
    \AxiomC{$\forall x (x \in A \cup \emptyset \iff x \in A \vee t \in \emptyset)$}
    \UnaryInfC{$t \in A \cup \emptyset \iff t \in A \vee t \in \emptyset$}
    \BinaryInfC{$t \in A \cup \emptyset$}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A \rightarrow t \in A \cup \emptyset$}
    \DisplayProof
\end{center}
    
De $(i)$ e $(ii)$, concluímos que $ (t \in A \cup \emptyset \rightarrow t \in A ) \wedge (t \in A \rightarrow t \in A \cup \emptyset) $, ou seja, $t \in A \cup \emptyset \iff t \in A $.

Como $t$ é arbitrário, é permitido dizer que temos $\forall x (x \in A \cup \emptyset \iff x \in A) $.

Portanto, temos $A \cup \emptyset = A$, se aplicarmos o Axioma da Extensão no resultado obtido no parágrafo acima.

\qquad

\end{itemize}

\item{\textbf{Comutatividade}}
\begin{itemize}
\item $A \cap B = B \cap A$ (a prova desta identidade escontra-se na seção de Provas de Teoremas)
\item $A \cup B = B \cup A$
\end{itemize}

\item{\textbf{Associatividade}}
\begin{itemize}
\item $(A \cap B) \cap C = A \cap (B \cap C)$
\item $(A \cup B) \cup C = A \cup (B \cup C)$
\end{itemize}

\item{\textbf{Distributividade}}
\begin{itemize}
\item $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$
\item $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$

\textbf{Prova em Lean:}
\begin{lstlisting}
example : A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C) :=
eq_of_subset_of_subset
    (assume x,
    assume h : x ∈ A ∪ (B ∩ C),
    or.elim h
        (assume h₁ : x ∈ A,
        have h₂ : x ∈ A ∪ B, from or.inl h₁,
        have h₃ : x ∈ A ∪ C, from or.inl h₁,
        show x ∈ (A ∪ B) ∩ (A ∪ C), from and.intro h₂ h₃)
        (assume h₁ : x ∈ B ∩ C,
        have h₂ : x ∈ B, from and.left h₁,
        have h₃ : x ∈ C, from and.right h₁,
        have h₄ : x ∈ A ∪ B, from or.inr h₂,
        have h₅ : x ∈ A ∪ C, from or.inr h₃,
        show x ∈ (A ∪ B) ∩ (A ∪ C), from and.intro h₄ h₅))
    (assume x,
    assume h : x ∈ (A ∪ B) ∩ (A ∪ C),
    have h₁ : x ∈ A ∪ B, from and.left h,
    have h₂ : x ∈ A ∪ C, from and.right h,
    or.elim h₁
        (assume h₃ : x ∈ A,
        show x ∈ A ∪ (B ∩ C), from or.inl h₃)
        (assume h₃ : x ∈ B,
        or.elim h₂
            (assume h₄ : x ∈ A,
            show x ∈ A ∪ (B ∩ C), from or.inl h₄)
            (assume h₄ : x ∈ C,
            have h₅ : x ∈ B ∩ C, from and.intro h₃ h₄,
            show x ∈ A ∪ (B ∩ C), from or.inr h₅))) \end{lstlisting}

\end{itemize}

\item{\textbf{Complementar/Lei de Demorgan}}
\begin{itemize}
\item $\mathcal U ^c = \emptyset$
\item $\emptyset ^c = \mathcal U$

\qquad

\item $A \cap \overline{A} = \emptyset$

\textbf{Prova:}
    
    Iremos utilizar, nesta prova, as definições de conjunto complementar, interseção e do conjunto vazio. Caso não se recorde, volte a seção de "Fundamentação", na parte "Definições".
    
    $(i)$ Provaremos que, para um $t$ arbitrário, $ t \in A \cap \overline A \rightarrow t \in \emptyset $ (como esta prova é muito extensa, para caber na página ,iremos modularizar ela) :
    
    \{$*$
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap \overline A$}
        \AxiomC{$\forall x (x \in A \cap \overline A \iff x \in A \wedge x \in \overline A)$}
        \UnaryInfC{$t \in A \cap \overline A \iff t \in A \wedge t \in \overline A$}
        \BinaryInfC{$t \in A \land t \in \overline A $}
        \DisplayProof
    \end{center}
    $*$\}
    
    \qquad
    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$*$}
        \UnaryInfC{$t \in A \land t \in \overline A $}
        \UnaryInfC{$t \in A $}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$*$}
        \UnaryInfC{$t \in A \land t \in \overline A $}
        \UnaryInfC{$t \in \overline A $}
        \AxiomC{$\forall x (x \in \overline {A} \iff x \notin A)$}
        \UnaryInfC{$t \in \overline {A} \iff t \notin A$}
        \BinaryInfC{$t \notin {A}$}
        \BinaryInfC{$\bot$}
        \UnaryInfC{$t \in \emptyset$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in A \cap \overline A \rightarrow t \in \emptyset$}
        \DisplayProof
    \end{center}
    
    \qquad
    
    $(ii)$ Provaremos que, para $t$ arbitrário, vale $ t \in \emptyset \rightarrow t \in A \cap \overline A$ :
    
    \begin{center}
        \AxiomC{}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in \emptyset$}
        \AxiomC{$\forall x (x \in \emptyset \iff \bot)$}
        \UnaryInfC{$t \in \emptyset \iff \bot$}
        \BinaryInfC{$\perp$}
        \UnaryInfC{$t \in A \cap \overline A$}
        \RightLabel{\scriptsize $1$}
        \UnaryInfC{$t \in \emptyset \rightarrow t \in A \cap \overline A$}
        \DisplayProof
    \end{center}
    
    De $(i)$ e $(ii)$, teremos  $ (t \in A \cap \overline A \rightarrow t \in \emptyset) \wedge (t \in \emptyset \rightarrow t \in A \cap \overline A)$, ou seja, $t \in A \cap \overline A \iff t \in \emptyset $.
    
    De $t$ arbitrário, $\forall x (x \in A \cap \overline A \iff x \in \emptyset)$
    
    Logo, utilizando o Axioma da Extensão, chegamos a $A \cap \overline{A} = \emptyset$.

\qquad

\item $A \cup A^c = \mathcal U$

\qquad

\item $\overline {\overline {A}} = A$

\textbf{Prova:}

\qquad

 Iremos utilizar, na prova a seguir, a definição de conjunto complementar. Caso não se recorde, volte a seção de "Fundamentação", na parte "Definições".
 
 \qquad

$(i)$ Provaremos que, para um $t$ qualquer, vale $ t \in \overline {\overline {A}} \rightarrow t \in A $ :
   
   
    
\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in \overline {\overline {A}}$}
    \AxiomC{$\forall x (x \in \overline {\overline {A}} \iff x \notin \overline {A})$}
    \UnaryInfC{$t \in \overline {\overline {A}} \iff t \notin \overline {A}$}
    \BinaryInfC{$t \notin \overline {A}$}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$t \notin A$}
    \AxiomC{$\forall x (x \in \overline {A} \iff x \notin A)$}
    \UnaryInfC{$t \in \overline {A} \iff t \notin A$}
    \BinaryInfC{$t \in \overline {A}$}
    \BinaryInfC{$\bot$}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$t \in A$}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$  t \in \overline {\overline {A}} \rightarrow t \in A $}
    \DisplayProof
\end{center}
        
\qquad

$(ii)$ Provaremos que $ t \in A \rightarrow t \in \overline {\overline {A}}$ :
\begin{center}
    \AxiomC{}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$t \in A$}
    \AxiomC{}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$t \in \overline A$}
    \AxiomC{$\forall x (x \in \overline{A} \iff x \notin A)$}
    \UnaryInfC{$t \in \overline{A} \iff t \notin A$}
    \BinaryInfC{$t \notin A$}
    \BinaryInfC{$\bot$}
    \RightLabel{\scriptsize $2$}
    \UnaryInfC{$t \notin \overline A$}
    \AxiomC{$\forall x (x \in \overline {\overline{A}} \iff x \notin \overline{A})$}
    \UnaryInfC{$t \in \overline {\overline{A}} \iff t \notin \overline{A}$}
    \BinaryInfC{$t \in \overline {\overline{A}}$}
    \RightLabel{\scriptsize $1$}
    \UnaryInfC{$  t \in {A} \rightarrow t \in \overline {\overline{A}}$}
    \DisplayProof
\end{center}

Assim, de $(i)$ e $(ii)$,temos $  (t \in \overline {\overline {A}} \rightarrow t \in A) \wedge (t \in {A} \rightarrow t \in \overline {\overline{A}} )$, ou seja, $t \in \overline {\overline {A}} \iff \in A $.

Como $t$ é arbitrário, chegamos em $\forall x (x \in \overline {\overline {A}} \iff x \in A) $.

Portanto, pelo Axioma da Extensão, concluímos que $\overline {\overline {A}} = A$.

\qquad

\item $(A \cap B)^c = A^c \cup B^c$
\item $(A \cup B)^c = A^c \cap B^c$
\end{itemize}

\item{\textbf{Lei da Absorção}}
\begin{itemize}
\item $A \cap (A \cup B) = A$

\begin{lstlisting}
lemma inter_subseq (H : Type)(P Q : set H) : P ∩ (P ∪ Q) = P :=
eq_of_subset_of_subset
  (assume x,
    assume h : x ∈ P ∩ (P ∪ Q),
    show x ∈ P, from h.left)
  (assume x,
    assume h : x ∈ P,
    have h₁ : x ∈ P ∪ Q, from or.inl h,
    show x ∈ P ∩ (P ∪ Q), from and.intro h h₁)\end{lstlisting}

\item $A \cup (A \cap B) = A$
\end{itemize}

\item{\textbf{Extras}}
\begin{itemize}
\item $A \setminus B = A \cap B^c$
\end{itemize}
\end{enumerate}

\section{Cálculo em Conjuntos}
Podemos provar que dois conjuntos são iguais argumentando sobre seus elementos, ou podemos ser mais eficientes e utilizar o cálculo juntamente com as propriedades vistas na seção $5.6$. Veja alguns exemplos:

\textbf{Exemplo 1:} Demonstre que $(A \setminus B)^c = A^c \cup B$

\textbf{Prova:} Utilizando cálculo:
\begin{equation*}
\begin{aligned}
  (A \setminus B)^c &= (A \cap B^c)^c)\\
  &= A^c \cup (B^c)^c\\
  & = A^c \cup B
\end{aligned}
\end{equation*}

$\qquad$

Relembrando um dos exemplos da seção $5.3$:

\textbf{Exemplo 2:} Demonstre que $(A \setminus B) \cup (B \setminus A) = (A \cup B) \setminus (A \cap B)$

\textbf{Prova:} Utilizando cálculo:
\begin{equation*}
\begin{aligned}
  (A \setminus B) \cup (B \setminus A) &= (A \cap B^c) \cup (B \cap A^c)\\
  &= ((A \cap B^c) \cup B) \cap ((A \cap B^c) \cup A^c)\\
  &= ((A \cup B) \cap (B^c \cup B)) \cap ((A \cup A^c) \cap (B^c \cup A^c))\\
  &= ((A \cup B) \cap \mathcal U) \cap (\mathcal U \cap (B^c \cup A^c))\\
  &= (A \cup B) \cap (B^c \cup A^c)\\
  &= (A \cup B) \cap (A^c \cup B^c)\\
  &= (A \cup B) \cap (A \cap B)^c\\
  &= (A \cup B) \setminus (A \cap B)
\end{aligned}
\end{equation*}

COLOCAR ALGO AQUI

Nos próximos exemplos, omitimos as quatro primeiras linhas, no entanto, lembre-se que elas existem, e devem ser incluídas no uso do provador.

\begin{lstlisting}
    import data.set
    open set
    variable U : Type
    variables A B C : set U

    example (h : A = B) : B = A :=
      calc
        B = A : eq.symm h
\end{lstlisting}

Nesse caso, utilizamos {\fontencoding{U}\fontfamily{cmtt}\selectfont eq.symm h}, que já nos deu a igualdade {\fontencoding{U}\fontfamily{cmtt}\selectfont B = A} direto. Mas tem outro jeito. Podemos querer somente baseado em {\fontencoding{U}\fontfamily{cmtt}\selectfont h}, reescrever {\fontencoding{U}\fontfamily{cmtt}\selectfont B}, e para isso utilizamos a tática {\fontencoding{U}\fontfamily{cmtt}\selectfont rewrite}.

\begin{lstlisting}
example (h : A = B) : B = A :=
calc
  B = A : by rewrite h \end{lstlisting}

Sempre utilizaremos essa tática quando quisermos a partir de uma igualdade, reescrever alguma parte da expressão, e pra agilizar o processo, ela pode ser abreviada para somente {\fontencoding{U}\fontfamily{cmtt}\selectfont rw}.
Podemos também escrever isso como lema/teorema e ainda colocar o universo e os conjuntos na definição dele (nesse caso, excluimos as linhas $3$ e $4$ que definem variáveis, omitidas anteriormente), veja:

\begin{lstlisting}
lemma a_eq_b {U : Type} (A B : set U) (h : A = B) : B = A :=
calc
  B = A : by rw h \end{lstlisting}

É evidente que o nosso objetivo não é utilizar {\fontencoding{U}\fontfamily{cmtt}\selectfont calc} somente para coisas tão simples. Queremos usar diversas propriedades sobre conjuntos que já estão a nossa disposição, para provar cada vez mais novas propriedades, como o exemplo a seguir:

\textbf{Exemplo 1:} Demonstre que $(A \setminus B)^c = A^c \cup B$.
\begin{lstlisting}
example : -(A \ B) = -A ∪ B :=
calc
  -(A \ B) = -(A ∩ -B)  : by rw diff_eq
       ... = -A ∪ -(-B) : by rw compl_inter
       ... = -A ∪ B     : by rw compl_compl \end{lstlisting}

Para aquelas pessoas que gostam de ser minimalistas e tentam usar o mínimo de linhas possível, existe como reduzir a prova em {\fontencoding{U}\fontfamily{cmtt}\selectfont calc} pra somente uma linha, veja:

\begin{lstlisting}
example : -(A \ B) = -A ∪ B :=
calc
  -(A \ B) = -A ∪ B : by rw [diff_eq, compl_inter, compl_compl]
--OU
example : -(A \ B) = -A ∪ B :=
by rw [diff_eq, compl_inter, compl_compl] \end{lstlisting}

Todavia, não é factível esperar que todo mundo adivinhe o nome dos lemas que representam cada propriedade para então poder utilizá-los em provas de cálculo. Por esse fato, apresentamos a seguir os nomes dos lemas para todas as propriedades da seção anterior e entre parênteses, a sua versão caso os conjuntos estejam na ordem inversa.

\begin{itemize}
\item $A \cap A = A$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_self}
\item $A \cup A = A$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont union\_self}
\item $A \cap \mathcal U = A$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_univ} ({\fontencoding{U}\fontfamily{cmtt}\selectfont univ\_inter})
\item $A \cup \mathcal U = \mathcal U$ : não existe
\item $A \cap \emptyset = \emptyset$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_empty} ({\fontencoding{U}\fontfamily{cmtt}\selectfont empty\_inter})
\item $A \cup \emptyset = A$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont union\_empty} ({\fontencoding{U}\fontfamily{cmtt}\selectfont empty\_union})
\item $\mathcal U ^c = \emptyset$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont compl\_univ}
\item $\emptyset ^c = \mathcal U$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont compl\_empty}
\item $A \cap A^c = \emptyset$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_compl\_self} ({\fontencoding{U}\fontfamily{cmtt}\selectfont compl\_inter\_self})
\item $A \cup A^c = \mathcal U$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont union\_compl\_self} ({\fontencoding{U}\fontfamily{cmtt}\selectfont compl\_union\_self})
\item $(A^c)^c = A$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont compl\_compl}
\item $A \cap B = B \cap A$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_comm}
\item $A \cup B = B \cup A$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont union\_comm}
\item $(A \cap B) \cap C = A \cap (B \cap C)$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_assoc}
\item $(A \cup B) \cup C = A \cup (B \cup C)$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont union\_assoc}
\item $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_distrib\_left} ({\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_distrib\_right})
\item $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont union\_distrib\_left} ({\fontencoding{U}\fontfamily{cmtt}\selectfont union\_distrib\_right})
\item $(A \cap B)^c = A^c \cup B^c$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont compl\_inter}
\item $(A \cup B)^c = A^c \cap B^c$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont compl\_union}
\item $A \setminus B = A \cap B^c$ : {\fontencoding{U}\fontfamily{cmtt}\selectfont diff\_eq}
\end{itemize}

Com toda essa bagagem já somos capazes de fazer provas bem mais complexas e que envolvem diversos passos, como a seguir:

\textbf{Exemplo 2:} Demonstre que $(A \setminus B) \cup (B \setminus A) = (A \cup B) \setminus (A \cap B)$
\begin{lstlisting}
example : (A \ B) ∪ (B \ A) = (A ∪ B) \ (A ∩ B) :=
calc
  (A \ B) ∪ (B \ A) = (A ∩ -B) ∪ (B \ A) : by rw diff_eq
  ... = (A ∩ -B) ∪ (B ∩ -A) : by rw diff_eq
  ... = ((A ∩ -B) ∪ B) ∩ ((A ∩ -B) ∪ -A) : by rw union_distrib_left
  ... = ((A ∪ B) ∩ (-B ∪ B)) ∩ ((A ∩ -B) ∪ -A) : by rw union_distrib_right
  ... = ((A ∪ B) ∩ univ) ∩ ((A ∩ -B) ∪ -A) : by rw compl_union_self
  ... = (A ∪ B) ∩ ((A ∩ -B) ∪ -A) : by rw inter_univ
  ... = (A ∪ B) ∩ ((A ∪ -A) ∩ (-B ∪ -A)) : by rw union_distrib_right
  ... = (A ∪ B) ∩ (univ ∩ (-B ∪ -A)) : by rw union_compl_self
  ... = (A ∪ B) ∩ (-B ∪ -A) : by rw univ_inter
  ... = (A ∪ B) ∩ -(B ∩ A) : by rw compl_inter
  ... = (A ∪ B) ∩ -(A ∩ B) : by rw inter_comm B A
  ... = (A ∪ B) \ (A ∩ B) : by rw diff_eq \end{lstlisting}

O leitor bem atento já notou uma pequena diferença na linha $13$ do código, não escrevemos {\fontencoding{U}\fontfamily{cmtt}\selectfont by rw inter\_comm}, mas sim {\fontencoding{U}\fontfamily{cmtt}\selectfont by rw inter\_comm B A}. Isso é necessário, porque na expressão dessa linha existem $2$ símbolos de intersecção em que poderia ser aplicado o lema, criando uma ambiguidade pro provador decidir em qual deles vai aplicá-lo. Quando isso acontece, o provador sempre escolhe a primeira ocorrência, ou seja, quando aplicamos o lema {\fontencoding{U}\fontfamily{cmtt}\selectfont inter\_comm} na expressão {\fontencoding{U}\fontfamily{cmtt}\selectfont (A ∪ B) ∩ -(B ∩ A)}, obtemos {\fontencoding{U}\fontfamily{cmtt}\selectfont -(B ∩ A) ∩ (A ∪ B)}. Entretanto, o objetivo é {\fontencoding{U}\fontfamily{cmtt}\selectfont (A ∪ B) ∩ -(A ∩ B)}, e para especificar isso, é só passar depois do lema os parâmetros que queremos que ele seja aplicado, no nosso caso, {\fontencoding{U}\fontfamily{cmtt}\selectfont B A}.

Outro caso de ambiguidade que também vemos nesse exemplo, está na linha $4$. A expressão anterior é {\fontencoding{U}\fontfamily{cmtt}\selectfont (A ∩ -B) ∪ (B $\setminus$ A)}, ou seja, temos dois termos possíveis para aplicar o lema {\fontencoding{U}\fontfamily{cmtt}\selectfont diff\_eq}, podemos reescrever {\fontencoding{U}\fontfamily{cmtt}\selectfont (A ∩ -B)} como {\fontencoding{U}\fontfamily{cmtt}\selectfont (A $\setminus$ B)} ou podemos reescrever  {\fontencoding{U}\fontfamily{cmtt}\selectfont (B $\setminus$ A)} como {\fontencoding{U}\fontfamily{cmtt}\selectfont (B ∩ -A)}. Nesse caso, o Lean prioriza a ida do lemma, que significa transformar o lado esquerdo da igualdade no lado direito (veja a lista de propriedades novamente pra entender melhor), e demos sorte de ser exatamente o que queríamos. Para fazer o inverso, só precisamos especificar os parâmetros pro lema: {\fontencoding{U}\fontfamily{cmtt}\selectfont by rw diff\_eq A B}.

Em algumas vezes, é necessário colocar cada parâmetro entre parênteses. Por exemplo, se um parâmetro for parecido com {\fontencoding{U}\fontfamily{cmtt}\selectfont -(A ∩ B) ∩ C}, o que vamos escrever depois do lemma é {\fontencoding{U}\fontfamily{cmtt}\selectfont (-(A ∩ B) ∩ C)} e os outros parâmetros.

\textbf{Exemplo 3:} Demonstre que $(A \cup B \cup C \cup D)^c = (A \cup B)^c \cap (C \cup D)^c$.

\begin{lstlisting}
example : -(A ∪ B ∪ C ∪ D) = -(A ∪ B) ∩ -(C ∪ D) :=
calc
  -(A ∪ B ∪ C ∪ D) = -(A ∪ B ∪ C) ∩ -D : by rw compl_union
  ... = -(A ∪ B) ∩ -C ∩ -D : by rw compl_union
  ... = -(A ∪ B) ∩ (-C ∩ -D) : by rw inter_assoc (-(A ∪ B)) (-C) (-D)
  ... = -(A ∪ B) ∩ -(C ∪ D) : by rw compl_union C D \end{lstlisting}

Esse é um ótimo exemplo de especificação de parâmetros no lema, entretanto, a $5$ linha está confundindo bastante. Após as duas primeiras transformações, o Lean interpreta que {\fontencoding{U}\fontfamily{cmtt}\selectfont -(A ∪ B) ∩ -C ∩ -D = (-(A ∪ B) ∩ -C) ∩ -D} implicitamente. Logo, precisamos utilizar a associatividade para rearranjar a expressão de uma maneira que podemos continuar trabalhando com ela.

Antes de finalizarmos a seção, saiba que os lemas que usamos dentro do {\fontencoding{U}\fontfamily{cmtt}\selectfont calc}, não precisam ser já criados dentro do Lean. Você pode criar um lema, prová-lo e depois utilizá-lo para provar outros lemas, o que se torna muito divertido!
\section{Famílias Indexadas}

\subsection{Definição}
Ainda vai ter algo escrito aqui

\subsection{Em Lean}
Ainda vai ter algo escrito aqui

\section{Conjunto das Partes}

\subsection{Definição}
Seja um conjunto $A$, o conjunto das partes de $A$, representado por $\wp(A)$, é o conjunto formado por todos os subconjuntos de $A$.

Os elementos de um conjunto das partes são, na verdade, outros conjuntos, e mais precisamente, são todos os subconjuntos que podem ser formados a partir dos elementos do conjunto de referência.

\textbf{Exemplo 1:}  Seja $A = \{a,b,c\}$ o conjunto referência.
O conjunto das partes de $A$ é $\wp(A)
= \{\emptyset,\{a\},\{b\},\{c\},\{a,b\},\{a,c\},\{b,c\},\{a,b,c\}\}$: 

\subsection{Cardinalidade}
Se um conjunto $A$ possui $n$ elementos, então o número de subconjuntos de $A$ é igual $2^A$.

De fato, no \textbf{Exemplo 1}, o conjunto das partes $\wp(A)$ possui 8 elementos e $A$ possui 3 elementos, como $2^3 = 8$, temos uma prova para a cardinalidade de conjuntos das parte.

Agora, iremos provar no caso de $A$ ter $k$ elementos: ($k \in  \mathbb{N}$) 

A demonstração para esse caso é bastante simples, vamos utilizar o \textbf{Princípio Fundamental da Contagem} para contar quantos subconjuntos o conjunto $A$ possui.

Vamos criar um subconjunto qualquer $B$. Para cada um dos $k$ elementos de A, existem somente duas possibilidades:

\begin{itemize}

\item Ou o elemento está no subconjunto $B$;
    
\item Ou o elemento não está no subconjunto $B$.
  
\end{itemize}

Assim, pelo \textbf{PFC}, nós podemos montar o conjunto $B$ de
\begin{center}
    $\underbrace{\begin{matrix} 2\cdot2\cdot2\cdot(\cdots)\cdot2\end{matrix}}_{k} = 2^k$ maneiras.
\end{center}
E, portanto, há todos os $2^k$ subconjuntos de $A$ em $\wp(A)$.

\subsection{Conjuntos das Partes em Lean}
Em lean, trataremos ``Conjuntos das Partes" como {\fontencoding{U}\fontfamily{cmtt}\selectfont powerset}, e pode ser definido da seguinte forma:
\begin{lstlisting}
variable {U : Type}

def powerset (A : set U) : set (set U) := {B : set U | B ⊆ A}

example (A B : set U) (h : B ∈ powerset A) : B ⊆ A := h \end{lstlisting}

Como está exposto na linha 5 do template, $B \in \wp(A)$ é, por definição, o mesmo que $B \subseteq A$.

De fato, a função {\fontencoding{U}\fontfamily{cmtt}\selectfont powerset} é definida desta forma em Lean, e fica disponível com os comandos: {\fontencoding{U}\fontfamily{cmtt}\selectfont import data.set} e {\fontencoding{U}\fontfamily{cmtt}\selectfont open set}. Abaixo temos o \textbf{Exemplo 2} de como utilizar esta função:
\begin{lstlisting}
import data.set
open set

variable  {U : Type}
variables (A B : set U)
--Exemplo 2
example : A ∈ powerset (A ∪ B) :=
assume x,
assume h : x ∈ A,
show x ∈ A ∪ B, from or.inl h

#check powerset A \end{lstlisting}


\section{Exercícios}
\begin{enumerate}

\item Realize as provas das seguintes propriedades: (Fornecendo uma prova tradicional e uma em Lean.)

\begin{enumerate}

\item Comutatividade em ∩ e ∪
\begin{lstlisting}
import data.set
open set

variable U : Type
variables A B : set U

example : A ∩ B = B ∩ A :=
eq_of_subset_of_subset
(assume x,
    assume h : x ∈ A ∩ B,
    have h₁ : x ∈ A, from h.left,
    have h₂ : x ∈ B, from h.right,
    show x ∈ B ∩ A, from and.intro h₂ h₁)
(assume x,
    assume h : x ∈ B ∩ A,
    have h₁ : x ∈ B, from h.left,
    have h₂ : x ∈ A, from h.right,
    show x ∈ A ∩ B, from and.intro h₂ h₁)

example : A ∪ B = B ∪ A:=
eq_of_subset_of_subset
(assume x,
    assume h : x ∈ A ∪ B,
    or.elim h
    (assume h₁ : x ∈ A,
    show x ∈ B ∪ A, from or.inr h₁)
    (assume h₁ : x ∈ B,
    show x ∈ B ∪ A, from or.inl h₁))
(assume x,
    assume h : x ∈ B ∪ A,
    or.elim h
    (assume h₁ : x ∈ B,
    show x ∈ A ∪ B, from or.inr h₁)
    (assume h₁ : x ∈ A,
    show x ∈ A ∪ B, from or.inl h₁)) \end{lstlisting}

$\qquad$
\item Associatividade em ∩ e ∪
\begin{lstlisting}
import data.set
open set

variable U : Type
variables A B C : set U

example : (A ∩ B) ∩ C = A ∩ (B ∩ C) :=
eq_of_subset_of_subset
(assume x,
    assume h : x ∈ (A ∩ B) ∩ C,
    have h₁ : x ∈ A ∩ B, from h.left,
    have h₂ : x ∈ B ∩ C, from and.intro h₁.right h.right,
    show x ∈ A ∩ (B ∩ C), from and.intro h₁.left h₂) 
(assume x,
    assume h : x ∈ A ∩ (B ∩ C),
    have h₁ : x ∈ B ∩ C, from h.right,
    have h₂ : x ∈ A ∩ B, from and.intro h.left h₁.left,
    show x ∈ (A ∩ B) ∩ C, from and.intro h₂ h₁.right) 

example : (A ∪ B) ∪ C = A ∪ (B ∪ C) :=
eq_of_subset_of_subset
(assume x,
    assume h : x ∈ (A ∪ B) ∪ C,
    or.elim h
        (assume h₁ : x ∈ A ∪ B,
        or.elim h₁
            (assume h₂ : x ∈ A,
            show x ∈ A ∪ (B ∪ C), from or.inl h₂)
            (assume h₂ : x ∈ B,
            have h₃ : x ∈ B ∪ C, from or.inl h₂,
            show x ∈ A ∪ (B ∪ C), from or.inr h₃))
        (assume h₁ : x ∈ C,
        have h₂ : x ∈ B ∪ C, from or.inr h₁,
        show x ∈ A ∪ (B ∪ C), from or.inr h₂))
(assume x,
    assume h : x ∈ A ∪ (B ∪ C),
    or.elim h
        (assume h₁ : x ∈ A,
        have h₂ : x ∈ A ∪ B, from or.inl h₁,
        show x ∈ (A ∪ B) ∪ C, from or.inl h₂)
        (assume h₁ : x ∈ B ∪ C,
        or.elim h₁
            (assume h₂ : x ∈ B,
            have h₃ : x ∈ A ∪ B, from or.inr h₂,
            show x ∈ (A ∪ B) ∪ C, from or.inl h₃)
            (assume h₂ : x ∈ C,
            show x ∈ (A ∪ B) ∪ C, from or.inr h₂))) \end{lstlisting}

$\qquad$
\item Distribuitividade (Dica: veja o exemplo utilizado na seção ``Propriedades")
\begin{lstlisting}
import data.set
open set

variable U : Type
variables A B C : set U

example : A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C) :=
eq_of_subset_of_subset
(assume x,
    assume h : x ∈ A ∩ (B ∪ C),
    have h.r : x ∈ B ∪ C, from h.right,
    or.elim h.r
        (assume h₁ : x ∈ B,
        have h₂ : x ∈ A ∩ B, from and.intro h.left h₁,
        show x ∈ (A ∩ B) ∪ (A ∩ C), from or.inl h₂)
        (assume h₁ : x ∈ C,
        have h₂ : x ∈ A ∩ C, from and.intro h.left h₁,
        show x ∈ (A ∩ B) ∪ (A ∩ C), from or.inr h₂))
(assume x,
    assume h : x ∈ (A ∩ B) ∪ (A ∩ C),
    or.elim h
        (assume h₁ : x ∈ A ∩ B,
        have h₂ : x ∈ B ∪ C, from or.inl h₁.right,
        show x ∈ A ∩ (B ∪ C), from and.intro h₁.left h₂)
        (assume h₁ : x ∈ A ∩ C,
        have h₂ : x ∈ B ∪ C, from or.inr h₁.right,
        have h₃ : x ∈ A, from h₁.left,
        show x ∈ A ∩ (B ∪ C), from and.intro h₃ h₂)) \end{lstlisting}

$\qquad$
\item Lei da Absorção (Dica: veja o exemplo utilizado em ``Propriedades")
\begin{lstlisting}
import data.set
open set

variable U : Type
variables A B : set U

example : A ∩ (A ∪ B) = A :=
eq_of_subset_of_subset
(assume x,
    assume h : x ∈ A ∩ (A ∪ B),
    show x ∈ A, from h.left)
(assume x,
    assume h : x ∈ A,
    have h₁ : x ∈ A ∪ B, from or.inl h,
    show x ∈ A ∩ (A ∪ B), from and.intro h h₁) \end{lstlisting}

$\qquad$
\item Lei de De Morgan
\begin{lstlisting}
import data.set
open set
open classical

variable U : Type
variables A B : set U

example : -(A ∩ B) = -A ∪ -B :=
ext (assume x, iff.intro
(assume h₁ : x ∈ -(A ∩ B),
    have g₁ : x ∈ (A ∪ -A), from em (x ∈ A),
    have g₂ : x ∈ (B ∪ -B), from em (x ∈ B),
    or.elim g₁
        (assume h₂ : x ∈ A, or.elim g₂
            (assume h₃ : x ∈ B, show x ∈ -A ∪ -B,
                from false.elim (h₁ ⟨h₂,h₃⟩))
            (assume h₃ : x ∈ -B, show x ∈ -A ∪ -B,
                from or.inr h₃))
        (assume h₂ : x ∈ -A, show x ∈ -A ∪ -B,
            from or.inl h₂))
(assume h₁ : x ∈ -A ∪ -B,
    assume h₂ : x ∈ (A ∩ B), show false,
    from or.elim h₁
        (assume h₃ : x ∈ -A, h₃ h₂.left )
        (assume h₃ : x ∈ -B, h₃ h₂.right)))

example : -(A ∪ B) = -A ∩ -B :=
ext (assume x, iff.intro
(assume h₁ : x ∈ -(A ∪ B),
    have g₁ : x ∈ -A, from
        assume h₂ : x ∈ A,
        have h₃ : x ∈ A ∪ B, from or.inl h₂, (h₁ h₃),
    have g₂ : x ∈ -B, from
        assume h₂ : x ∈ B,
        have h₃ : x ∈ A ∪ B, from or.inr h₂, (h₁ h₃),
    show x ∈ -A ∩ -B, from ⟨g₁, g₂⟩)
(assume h₁ : x ∈ -A ∩ -B,
    show x ∈ -(A ∪ B), from
        assume h₂ : x ∈ A ∪ B,
        or.elim h₂
            (assume h3 : x ∈ A, h₁.left h3)
            (assume h3 : x ∈ B, h₁.right h3))) \end{lstlisting}

\end{enumerate}

$\qquad$

\item Questões do capítulo 12 do livro Logic and Proof
\begin{lstlisting}
import data.set
open set

--Item 1 - Complete os exemplos abaixo, alterando as partes onde foi colocado sorry
section
variable U : Type
variables A B C : set U

example : ∀ x, x ∈ A ∩ C → x ∈ A ∪ B :=
sorry

example : ∀ x, x ∈ -(A ∪ B) → x ∈ -A :=
sorry
end


--Item 2 - Complete o exemplo abaixo, alterando a parte onde foi colocado sorry
section
variable {U : Type}

--definindo "conjuntos disjuntos"
def disj (A B : set U) : Prop := ∀ ⦃x⦄, x ∈ A → x ∈ B → false

example (A B : set U) (h : ∀ x, ¬ (x ∈ A ∧ x ∈ B)) :
  disj A B :=
assume x,
assume h1 : x ∈ A,
assume h2 : x ∈ B,
have h3 : x ∈ A ∧ x ∈ B, from and.intro h1 h2,
show false, from h x h3

-- observe que é excessivo mencionar x ao aplicar
-- h : disj A B
example (A B : set U) (h1 : disj A B) (x : U)
    (h2 : x ∈ A) (h3 : x ∈ B) :
  false :=
h1 h2 h3

-- o mesmo vale para ⊆
example (A B : set U) (x : U) (h : A ⊆ B) (h1 : x ∈ A) :
  x ∈ B :=
h h1

example (A B C D : set U) (h1 : disj A B) (h2 : C ⊆ A)
    (h3 : D ⊆ B) :
  disj C D :=
sorry
end

--Item 3 - Prove os seguintes exemplos sobre unioes e intersecoes indexadas,
--usando os teoremas: Inter.intro; Inter.elim; Union.intro; e Union.elim listados abaixo:
section
variables {I U : Type}
variables {A B : I → set U}

theorem Inter.intro {x : U} (h : ∀ i, x ∈ A i) : x ∈ ⋂ i, A i :=
by simp; assumption

@[elab_simple]
theorem Inter.elim {x : U} (h : x ∈ ⋂ i, A i) (i : I) : x ∈ A i :=
by simp at h; apply h

theorem Union.intro {x : U} (i : I) (h : x ∈ A i) : x ∈ ⋃ i, A i :=
by {simp, existsi i, exact h}

theorem Union.elim {b : Prop} {x : U}
(h₁ : x ∈ ⋃ i, A i) (h₂ : ∀ (i : I), x ∈ A i → b) : b :=
by {simp at h₁, cases h₁ with i h, exact h₂ i h}

end

-- Exemplos
section
variables {I U : Type}
variables (A : I → set U) (B : I → set U) (C : set U)

example : (⋂ i, A i) ∩ (⋂ i, B i) ⊆ (⋂ i, A i ∩ B i) :=
sorry

example : C ∩ (⋃i, A i) ⊆ ⋃i, C ∩ A i :=
sorry
end


--Item 4 -Prove os seguintes exemplos sobre conjunto das partes.
section
variable  {U : Type}
variables A B C : set U

--Use os teoremas: subset.trans e subset.refl
example (h1 : A ⊆ B) (h2 : B ⊆ C) : A ⊆ C :=
subset.trans h1 h2

example : A ⊆ A :=
subset.refl A

example (h : A ⊆ B) : powerset A ⊆ powerset B :=
sorry

example (h : powerset A ⊆ powerset B) : A ⊆ B :=
sorry
end\end{lstlisting}

%A seguir segue o gabarito dos itens dos execícios do capítulo 12 - Sets in Lean:
\begin{lstlisting}
import data.set
open set

--Item 1 - Complete os exemplos abaixo, alterando as partes onde foi colocado sorry
section
variable U : Type
variables A B C : set U

example : ∀ x, x ∈ A ∩ C → x ∈ A ∪ B :=
assume x,
assume h1 : x ∈ A ∩ C,
have h2 : x ∈ A, from and.left h1,
show x ∈ A ∪ B, from or.inl h2

example : ∀ x, x ∈ -(A ∪ B) → x ∈ -A :=
assume x,
assume h1 : x ∈ -(A ∪ B),
assume h2 : x ∈ A,
have h3 : x ∈ A ∪ B, from or.inl h2,
show false, from h1 h3
end


--Item 2 - Complete o exemplo abaixo, alterando a parte onde foi colocado sorry
section
variable {U : Type}

--definindo "conjuntos disjuntos"
def disj (A B : set U) : Prop := ∀ ⦃x⦄, x ∈ A → x ∈ B → false

example (A B : set U) (h : ∀ x, ¬ (x ∈ A ∧ x ∈ B)) :
  disj A B :=
assume x,
assume h1 : x ∈ A,
assume h2 : x ∈ B,
have h3 : x ∈ A ∧ x ∈ B, from and.intro h1 h2,
show false, from h x h3

-- observe que é excessivo mencionar x ao aplicar
-- h : disj A B
example (A B : set U) (h1 : disj A B) (x : U)
    (h2 : x ∈ A) (h3 : x ∈ B) :
  false :=
h1 h2 h3

-- o mesmo vale para ⊆
example (A B : set U) (x : U) (h : A ⊆ B) (h1 : x ∈ A) :
  x ∈ B :=
h h1

example (A B C D : set U) (h1 : disj A B) (h2 : C ⊆ A)
    (h3 : D ⊆ B) : disj C D :=
assume x,
assume h4 : x ∈ C,
assume h5 : x ∈ D,
have h6 : x ∈ A, from h2 h4,
have h7 : x ∈ B, from h3 h5,
show false, from h1 h6 h7
end

--Item 3 - Prove os seguintes exemplos sobre unioes e intersecoes indexadas,
--usando os teoremas: Inter.intro; Inter.elim; Union.intro; e Union.elim listados abaixo:
section
variables {I U : Type}
variables {A B : I → set U}

theorem Inter.intro {x : U} (h : ∀ i, x ∈ A i) : x ∈ ⋂ i, A i :=
by simp; assumption

@[elab_simple]
theorem Inter.elim {x : U} (h : x ∈ ⋂ i, A i) (i : I) : x ∈ A i :=
by simp at h; apply h

theorem Union.intro {x : U} (i : I) (h : x ∈ A i) : x ∈ ⋃ i, A i :=
by {simp, existsi i, exact h}

theorem Union.elim {b : Prop} {x : U}
(h₁ : x ∈ ⋃ i, A i) (h₂ : ∀ (i : I), x ∈ A i → b) : b :=
by {simp at h₁, cases h₁ with i h, exact h₂ i h}

end

-- Exemplos
section
variables {I U : Type}
variables (A : I → set U) (B : I → set U) (C : set U)

example : (⋂ i, A i) ∩ (⋂ i, B i) ⊆ (⋂ i, A i ∩ B i) :=
assume x,
assume h : x ∈ (⋂ i, A i) ∩ (⋂ i, B i),
Inter.intro
    (assume i : I,
    have h1 : x ∈ A i, from Inter.elim h.left i,
    have h2 : x ∈ B i, from Inter.elim h.right i,
    show x ∈ A i ∩ B i, from and.intro h1 h2)

example : C ∩ (⋃ i, A i) ⊆ ⋃ i, C ∩ A i :=
assume x,
assume h : x ∈ C ∩ (⋃ i, A i),
have h1 : x ∈ ⋃ i, A i, from h.right,
Union.elim h1
    (assume i : I,
    assume h2 : x ∈ A i,
    have h3 : x ∈ C ∩ A i, from and.intro h.left h2,
    show x ∈ ⋃ i, C ∩ A i, from Union.intro i h3)
end


--Item 4 -Prove os seguintes exemplos sobre conjunto das partes.
section
variable  {U : Type}
variables A B C : set U

--Use os teoremas: subset.trans e subset.refl
example (h1 : A ⊆ B) (h2 : B ⊆ C) : A ⊆ C :=
subset.trans h1 h2

example : A ⊆ A :=
subset.refl A

example (h : A ⊆ B) : powerset A ⊆ powerset B :=
assume x,
assume h1 : x ∈ powerset A,
have h2 : x ⊆ A, from h1,
have h3 : x ⊆ B, from subset.trans h2 h,
show x ∈ powerset B, from h3

example (h : powerset A ⊆ powerset B) : A ⊆ B :=
have h1 : ∀ x, x ∈ powerset A → x ∈ powerset B, from h,
have h2 : ∀ x, x ⊆ A → x ⊆ B, from
    (assume y,
    assume g1 : y ⊆ A,
    have g2 : y ∈ powerset A, from g1,
    have g3 : y ∈ powerset A → y ∈ powerset B, from h1 y,
    have g4 : y ∈ powerset B, from g3 g2,
    show y ⊆ B, from g4),
have h3 : A ⊆ A → A ⊆ B, from h2 A,
show A ⊆ B, from h3 (subset.refl A)
end \end{lstlisting}

$\qquad$


\item Prove que $A \cup \overline A = \mathcal U$. (Fornecendo uma prova tradicional e uma em Lean.)

\textbf{Resposta}

$\qquad$
\item Questões com calc

%adicionar questões do LEAN

\end{enumerate}
